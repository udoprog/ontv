use anyhow::Error;

use iced::theme;
use iced::widget::{button, column, image, row, scrollable, text, text_input};
use iced::{Color, Command, Element, Length};

use crate::message::Message;
use crate::model::SearchSeries;
use crate::page::settings;
use crate::service::Service;
use crate::thetvdb;

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum SearchMessage {
    /// Fire of a search with the current input.
    Search,
    /// On input change.
    Change(String),
    /// Search result from API.
    Result(Vec<SearchSeries>),
    /// Error when doing the search.
    Error(Box<str>),
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct State {
    text: String,
    series: Vec<SearchSeries>,
}

/// Handle theme change.
pub(crate) fn update(
    service: &Service,
    state: &mut State,
    settings: &settings::State,
    message: SearchMessage,
) -> Command<Message> {
    match message {
        SearchMessage::Error(error) => {
            log::error!("error when searching: {error}");
        }
        SearchMessage::Search => {
            let query = state.text.clone();
            let client = service.client.clone();

            let op = async move {
                let series = client.search_by_name(&query).await?;
                Ok::<_, Error>(series)
            };

            let op = async move {
                let message = match op.await {
                    Ok(series) => SearchMessage::Result(series),
                    Err(error) => SearchMessage::Error(error.to_string().into()),
                };

                Message::Search(message)
            };

            return Command::perform(op, |m| m);
        }
        SearchMessage::Change(text) => {
            state.text = text;
        }
        SearchMessage::Result(series) => {
            state.series = series;
        }
    }

    Command::none()
}

/// Generate the view for the settings page.
pub(crate) fn view(service: &Service, state: &State) -> Element<'static, Message> {
    let submit = button("Search");

    let submit = if !state.text.is_empty() {
        submit.on_press(Message::Search(SearchMessage::Search))
    } else {
        submit
    };

    let mut results = column![].spacing(20);

    for series in &state.series {
        let handle = service.get_image(&series.poster);

        results = results.push(row![
            image(handle).height(Length::Units(100)),
            column![
                text(&series.name).style(theme::Text::Color(Color::from_rgba(1.0, 0.0, 1.0, 1.0))),
                text(&series.overview),
            ]
        ]);
    }

    let column = column![
        text("Search"),
        row![
            text_input("Query...", &state.text, |value| Message::Search(
                SearchMessage::Change(value)
            )),
            submit,
        ],
        scrollable(results).height(Length::Fill),
    ]
    .width(Length::Fill)
    .spacing(10);

    column.into()
}

use anyhow::{anyhow, Context, Result};
use iced::widget::{button, image, radio, text, text_input, Column, Row};
use iced::{theme, Alignment, Commands, Element, Length};
use uuid::Uuid;

use crate::error::{ErrorId, ErrorInfo};
use crate::model::{RemoteSeriesId, SearchKind, SearchSeries, SeriesId, TaskKind};
use crate::params::{
    default_container, GAP, GAP2, IMAGE_HEIGHT, POSTER_HINT, SMALL, SPACE, TITLE_SIZE,
};
use crate::queue::TaskStatus;
use crate::state::{Page, State};

/// Number of results per page.
const PER_PAGE: usize = 5;

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum Message {
    Error(ErrorInfo),
    Navigate(Page),
    Search,
    Change(String),
    Page(usize),
    Result(Vec<SearchSeries>),
    SearchKindChanged(SearchKind),
    AddSeriesByRemote(RemoteSeriesId),
    SwitchSeries(SeriesId, RemoteSeriesId),
    RemoveSeries(SeriesId),
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct Search {
    text: String,
    series: Vec<SearchSeries>,
    page: usize,
    // Unique identifier of last search so that we can look up any recorded errors.
    search_id: Uuid,
}

impl Search {
    /// Prepare data that is needed for the view.
    pub(crate) fn prepare(&mut self, s: &mut State) {
        s.assets.mark_with_hint(
            self.series
                .iter()
                .skip(self.page * PER_PAGE)
                .take(PER_PAGE)
                .flat_map(|s| s.poster),
            POSTER_HINT,
        );
    }

    /// Handle theme change.
    pub(crate) fn update(
        &mut self,
        s: &mut State,
        message: Message,
        commands: impl Commands<Message>,
    ) {
        match message {
            Message::Error(error) => {
                s.handle_error(error);
            }
            Message::Navigate(page) => {
                s.push_history(page);
            }
            Message::Search => {
                self.search(s, commands);
            }
            Message::Change(text) => {
                self.text = text;
            }
            Message::Page(page) => {
                self.page = page;
                s.assets.clear();
            }
            Message::Result(series) => {
                self.series = series;
                s.assets.clear();
            }
            Message::SearchKindChanged(kind) => {
                s.service.config_mut().search_kind = kind;
                self.search(s, commands);
            }
            Message::AddSeriesByRemote(remote_id) => {
                s.service
                    .push_task(TaskKind::DownloadSeriesByRemoteId { remote_id }, None);
            }
            Message::SwitchSeries(series_id, remote_id) => {
                s.remove_series(&series_id);
                s.service
                    .push_task(TaskKind::DownloadSeriesByRemoteId { remote_id }, None);
            }
            Message::RemoveSeries(series_id) => {
                s.remove_series(&series_id);
            }
        }
    }

    fn search(&mut self, s: &mut State, mut commands: impl Commands<Message>) {
        if self.text.is_empty() {
            return;
        }

        self.page = 0;

        let search_id = Uuid::new_v4();
        let query = self.text.clone();
        let search_kind = s.service.config().search_kind;
        self.search_id = search_id;

        let translate = move |out: Result<_>| match out
            .with_context(|| anyhow!("Searching {search_kind} for `{query}`"))
        {
            Ok(series) => Message::Result(series),
            Err(error) => Message::Error(ErrorInfo::new(ErrorId::Search(search_id), error)),
        };

        match search_kind {
            SearchKind::Tvdb => {
                let op = s.service.search_tvdb(&self.text);
                commands.perform(op, translate);
            }
            SearchKind::Tmdb => {
                let op = s.service.search_tmdb(&self.text);
                commands.perform(op, translate);
            }
        }
    }

    /// Generate the view for the settings page.
    pub(crate) fn view(&self, s: &State) -> Element<'static, Message> {
        let mut results = Column::new();

        for series in self.series.iter().skip(self.page * PER_PAGE).take(PER_PAGE) {
            let local_series = s.service.get_series_by_remote(&series.id);

            let handle = match series
                .poster
                .and_then(|p| s.assets.image_with_hint(&p, POSTER_HINT))
            {
                Some(handle) => handle,
                None => s.missing_poster(),
            };

            let mut actions = Row::new();

            let status = s.service.task_status(&TaskKind::DownloadSeriesByRemoteId {
                remote_id: series.id,
            });

            match status {
                Some(TaskStatus::Pending) => {
                    actions = actions
                        .push(button(text("Queued...").size(SMALL)).style(theme::Button::Primary));
                }
                Some(TaskStatus::Running) => {
                    actions = actions.push(
                        button(text("Downloading...").size(SMALL)).style(theme::Button::Primary),
                    );
                }
                None => {
                    if let Some(s) = local_series {
                        if s.remote_id != Some(series.id) {
                            actions = actions.push(
                                button(text("Switch").size(SMALL))
                                    .style(theme::Button::Primary)
                                    .on_press(Message::SwitchSeries(s.id, series.id)),
                            );
                        }

                        actions = actions.push(
                            button(text("Remove").size(SMALL))
                                .style(theme::Button::Destructive)
                                .on_press(Message::RemoveSeries(s.id)),
                        );
                    } else {
                        actions = actions.push(
                            button(text("Add").size(SMALL))
                                .style(theme::Button::Positive)
                                .on_press(Message::AddSeriesByRemote(series.id)),
                        );
                    }
                }
            }

            let overview = series.overview.as_deref().unwrap_or_default();

            let mut first_aired = Column::new();

            if let Some(date) = series.first_aired {
                first_aired = first_aired.push(text(format!("First aired: {date}")).size(SMALL));
            }

            let mut result = Column::new();

            let series_name = text(&series.name).size(24);

            if let Some(local_series) = local_series {
                result = result.push(
                    button(series_name)
                        .style(theme::Button::Text)
                        .padding(0)
                        .on_press(Message::Navigate(Page::Series(local_series.id))),
                );
            } else {
                result = result.push(series_name);
            }

            result = result.push(first_aired);
            result = result.push(actions.spacing(SPACE));

            results = results.push(
                Row::new()
                    .push(image(handle).height(Length::Units(IMAGE_HEIGHT)))
                    .push(
                        Column::new()
                            .push(result.spacing(SPACE))
                            .push(text(overview))
                            .spacing(GAP),
                    )
                    .spacing(GAP),
            );
        }

        let mut pages = Row::new();

        if self.series.len() > PER_PAGE {
            let mut prev = button("previous page").style(theme::Button::Positive);
            let mut next = button("next page").style(theme::Button::Positive);

            if let Some(page) = self.page.checked_sub(1) {
                prev = prev.on_press(Message::Page(page));
            }

            if (self.page + 1) * PER_PAGE < self.series.len() {
                next = next.on_press(Message::Page(self.page + 1));
            }

            let text = text(format!(
                "{}-{} ({})",
                self.page * PER_PAGE,
                ((self.page + 1) * PER_PAGE).min(self.series.len()),
                self.series.len(),
            ));

            pages = Row::new()
                .push(prev)
                .push(next)
                .push(text)
                .align_items(Alignment::Center)
                .spacing(GAP);
        }

        let query = text_input("Query...", &self.text, Message::Change).on_submit(Message::Search);

        let submit = button("Search");

        let submit = if !self.text.is_empty() {
            submit.on_press(Message::Search)
        } else {
            submit
        };

        let mut search_kind = Column::new().push(text("Source:").size(SMALL));

        search_kind =
            [SearchKind::Tvdb, SearchKind::Tmdb]
                .iter()
                .fold(search_kind, |column, kind| {
                    column.push(
                        radio(
                            format!("{kind}"),
                            *kind,
                            Some(s.service.config().search_kind),
                            Message::SearchKindChanged,
                        )
                        .size(SMALL),
                    )
                });

        let mut page = Column::new();

        page = page.push(text("Search").size(TITLE_SIZE));
        page = page.push(Row::new().push(query).push(submit));

        if let Some(e) = s.get_error(ErrorId::Search(self.search_id)) {
            page = page.push(
                button(text(format!("Error: {}", e.message)))
                    .width(Length::Fill)
                    .style(theme::Button::Destructive)
                    .on_press(Message::Navigate(Page::Errors)),
            );
        }

        page = page.push(search_kind.spacing(SPACE));
        page = page.push(results.spacing(GAP2));
        page = page.push(pages);

        default_container(page.spacing(GAP).padding(GAP)).into()
    }
}

use core::fmt;

use iced::widget::{button, column, image, radio, row, text, text_input, Column, Row};
use iced::{theme, Alignment};
use iced::{Command, Length};

use crate::assets::Assets;
use crate::message::Message;
use crate::model::SearchSeries;
use crate::params::{
    default_container, ACTION_SIZE, GAP, GAP2, POSTER_HEIGHT, SMALL_SIZE, SPACE, TITLE_SIZE,
};
use crate::service::Service;

const PER_PAGE: usize = 5;

#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub(crate) enum SearchKind {
    #[default]
    Tvdb,
    Tmdb,
}

impl fmt::Display for SearchKind {
    #[inline]
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SearchKind::Tvdb => write!(f, "thetvdb.com"),
            SearchKind::Tmdb => write!(f, "themoviedb.com"),
        }
    }
}

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum M {
    /// Fire of a search with the current input.
    Search,
    /// On input change.
    Change(String),
    /// Go to a different page.
    Page(usize),
    /// Search result from API.
    Result(Vec<SearchSeries>),
    /// Change search kind.
    SearchKindChanged(SearchKind),
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct State {
    kind: SearchKind,
    text: String,
    series: Vec<SearchSeries>,
    page: usize,
}

impl State {
    /// Prepare data that is needed for the view.
    pub(crate) fn prepare(&mut self, _: &Service, assets: &mut Assets) {
        assets.mark(
            self.series
                .iter()
                .skip(self.page * PER_PAGE)
                .take(PER_PAGE)
                .flat_map(|s| s.poster),
        );
    }

    /// Handle theme change.
    pub(crate) fn update(
        &mut self,
        service: &mut Service,
        assets: &mut Assets,
        message: M,
    ) -> Command<Message> {
        match message {
            M::Search => self.search(service),
            M::Change(text) => {
                self.text = text;
                Command::none()
            }
            M::Page(page) => {
                self.page = page;
                assets.clear();
                Command::none()
            }
            M::Result(series) => {
                self.series = series;
                assets.clear();
                Command::none()
            }
            M::SearchKindChanged(kind) => {
                self.kind = kind;
                self.search(service)
            }
        }
    }

    fn search(&mut self, service: &mut Service) -> Command<Message> {
        if self.text.is_empty() {
            return Command::none();
        }

        self.page = 0;

        let query = self.text.clone();

        let translate = |out| match out {
            Ok(series) => Message::Search(M::Result(series)),
            Err(error) => Message::error(error),
        };

        match self.kind {
            SearchKind::Tvdb => {
                let tvdb = service.tvdb.clone();
                let op = async move { tvdb.search_by_name(&query).await };
                Command::perform(op, translate)
            }
            SearchKind::Tmdb => {
                let tmdb = service.tmdb.clone();
                let op = async move { tmdb.search_series(&query).await };
                Command::perform(op, translate)
            }
        }
    }

    /// Generate the view for the settings page.
    pub(crate) fn view(&self, service: &Service, assets: &Assets) -> Column<'static, Message> {
        let mut results = column![];

        for series in self.series.iter().skip(self.page * PER_PAGE).take(PER_PAGE) {
            let handle = match series.poster.and_then(|p| assets.image(&p)) {
                Some(handle) => handle,
                None => assets.missing_poster(),
            };

            let mut actions = Row::new();

            if service.is_downloading(&series.id) {
                actions = actions.push(
                    button(text("Downloading...").size(ACTION_SIZE)).style(theme::Button::Primary),
                );
            } else {
                if let Some(s) = service.get_series_by_remote(series.id) {
                    if s.remote_id != Some(series.id) {
                        actions = actions.push(
                            button(text("Switch").size(ACTION_SIZE))
                                .style(theme::Button::Primary)
                                .on_press(Message::SwitchSeries(s.id, series.id)),
                        );
                    }

                    actions = actions.push(
                        button(text("Remove").size(ACTION_SIZE))
                            .style(theme::Button::Destructive)
                            .on_press(Message::RemoveSeries(s.id)),
                    );
                } else {
                    actions = actions.push(
                        button(text("Add").size(ACTION_SIZE))
                            .style(theme::Button::Positive)
                            .on_press(Message::AddSeriesByRemote(series.id)),
                    );
                }
            }

            let overview = series
                .overview
                .as_ref()
                .map(|o| o.as_str())
                .unwrap_or_default();

            let mut first_aired = column![];

            if let Some(date) = series.first_aired {
                first_aired =
                    first_aired.push(text(format!("First aired: {date}")).size(SMALL_SIZE));
            }

            results = results.push(
                row![
                    image(handle).height(Length::Units(POSTER_HEIGHT)),
                    column![
                        column![
                            text(&series.name).size(24),
                            first_aired,
                            actions.spacing(SPACE)
                        ]
                        .spacing(SPACE),
                        text(overview),
                    ]
                    .spacing(GAP)
                ]
                .spacing(GAP),
            );
        }

        let mut pages = row![];

        if self.series.len() > PER_PAGE {
            let mut prev = button("previous page").style(theme::Button::Positive);
            let mut next = button("next page").style(theme::Button::Positive);

            if let Some(page) = self.page.checked_sub(1) {
                prev = prev.on_press(Message::Search(M::Page(page)));
            }

            if (self.page + 1) * PER_PAGE < self.series.len() {
                next = next.on_press(Message::Search(M::Page(self.page + 1)));
            }

            let text = text(format!(
                "{}-{} ({})",
                self.page * PER_PAGE,
                ((self.page + 1) * PER_PAGE).min(self.series.len()),
                self.series.len(),
            ));

            pages = Row::new()
                .push(prev)
                .push(next)
                .push(text)
                .align_items(Alignment::Center)
                .spacing(GAP);
        }

        let query = text_input("Query...", &self.text, |value| {
            Message::Search(M::Change(value))
        })
        .on_submit(Message::Search(M::Search));

        let submit = button("Search");

        let submit = if !self.text.is_empty() {
            submit.on_press(Message::Search(M::Search))
        } else {
            submit
        };

        let mut kind = Column::new().push(text("Source:"));
        kind = kind.push([SearchKind::Tvdb, SearchKind::Tmdb].iter().fold(
            Row::new().spacing(GAP),
            |column, kind| {
                column.push(radio(format!("{}", kind), *kind, Some(self.kind), |kind| {
                    Message::Search(M::SearchKindChanged(kind))
                }))
            },
        ));

        let page = Column::new()
            .push(text("Search").size(TITLE_SIZE))
            .push(row![query, submit])
            .push(kind.spacing(SPACE))
            .push(results.spacing(GAP2))
            .push(pages)
            .spacing(GAP)
            .padding(GAP);

        default_container(page)
    }
}

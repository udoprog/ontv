use anyhow::Error;

use iced::widget::{button, column, image, row, scrollable, text, text_input};
use iced::{theme, Alignment};
use iced::{Command, Element, Length};

use crate::message::Message;
use crate::model::SearchSeries;
use crate::params::{ACTION_BUTTON_SIZE, GAP, GAP2, SPACE};
use crate::service::Service;

const PER_PAGE: usize = 5;

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum SearchMessage {
    /// Fire of a search with the current input.
    Search,
    /// On input change.
    Change(String),
    /// Go to a different page.
    Page(usize),
    /// Search result from API.
    Result(Vec<SearchSeries>),
    /// Error when doing the search.
    Error(Box<str>),
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct State {
    text: String,
    series: Vec<SearchSeries>,
    page: usize,
}

/// Handle theme change.
pub(crate) fn update(
    service: &Service,
    state: &mut State,
    message: SearchMessage,
) -> Command<Message> {
    match message {
        SearchMessage::Error(error) => {
            log::error!("error when searching: {error}");
        }
        SearchMessage::Search => {
            state.page = 0;

            let query = state.text.clone();
            let client = service.client.clone();

            let op = async move {
                let series = client.search_by_name(&query).await?;
                Ok::<_, Error>(series)
            };

            let op = async move {
                let message = match op.await {
                    Ok(series) => SearchMessage::Result(series),
                    Err(error) => SearchMessage::Error(error.to_string().into()),
                };

                Message::Search(message)
            };

            return Command::perform(op, |m| m);
        }
        SearchMessage::Change(text) => {
            state.text = text;
        }
        SearchMessage::Page(page) => {
            state.page = page;
        }
        SearchMessage::Result(series) => {
            let mut ids = Vec::with_capacity(series.len());

            for s in &series {
                ids.push(s.poster);
            }

            state.series = series;
            return Command::perform(service.load_images(&ids), |m| m);
        }
    }

    Command::none()
}

/// Generate the view for the settings page.
pub(crate) fn view(service: &Service, state: &State) -> Element<'static, Message> {
    let submit = button("Search");

    let submit = if !state.text.is_empty() {
        submit.on_press(Message::Search(SearchMessage::Search))
    } else {
        submit
    };

    let mut results = column![].spacing(GAP2);

    for series in state
        .series
        .iter()
        .skip(state.page * PER_PAGE)
        .take(PER_PAGE)
    {
        let handle = service.get_image(&series.poster);

        let track = if service.is_thetvdb_tracked(series.id) {
            button(text("Untrack").size(ACTION_BUTTON_SIZE))
                .style(theme::Button::Destructive)
                .on_press(Message::Untrack(series.id))
        } else {
            button(text("Track").size(ACTION_BUTTON_SIZE))
                .style(theme::Button::Positive)
                .on_press(Message::Track(series.id))
        };

        let overview = series
            .overview
            .as_ref()
            .map(|o| o.as_str())
            .unwrap_or_default();

        results = results.push(
            column![
                row![
                    image(handle).height(Length::Units(100)),
                    column![text(&series.name).size(24), text(overview),].spacing(SPACE)
                ]
                .spacing(GAP),
                track,
            ]
            .spacing(GAP),
        );
    }

    let mut pages = row![];

    if state.series.len() > PER_PAGE {
        let mut prev = button("previous page");
        let mut next = button("next page");

        if let Some(page) = state.page.checked_sub(1) {
            prev = prev.on_press(Message::Search(SearchMessage::Page(page)));
        }

        if (state.page + 1) * PER_PAGE < state.series.len() {
            next = next.on_press(Message::Search(SearchMessage::Page(state.page + 1)));
        }

        pages = row![
            prev,
            text(format!(
                "{}-{} result(s)",
                state.page * PER_PAGE,
                ((state.page + 1) * PER_PAGE).min(state.series.len())
            )),
            next
        ]
        .align_items(Alignment::Center)
        .spacing(GAP);
    }

    let column = column![
        text("Search"),
        row![
            text_input("Query...", &state.text, |value| Message::Search(
                SearchMessage::Change(value)
            )),
            submit,
        ],
        scrollable(results).height(Length::Fill),
        pages,
    ]
    .width(Length::Fill)
    .spacing(GAP);

    column.into()
}

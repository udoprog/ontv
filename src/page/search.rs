use std::collections::VecDeque;

use anyhow::Result;
use iced::widget::{button, column, image, row, text, text_input, Column};
use iced::{theme, Alignment};
use iced::{Command, Length};
use iced_native::image::Handle;

use crate::message::Message;
use crate::model::{Image, RemoteSeriesId, SearchSeries};
use crate::params::{ACTION_SIZE, GAP, GAP2, SPACE};
use crate::service::Service;

const PER_PAGE: usize = 5;

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum M {
    /// Fire of a search with the current input.
    Search,
    /// On input change.
    Change(String),
    /// Go to a different page.
    Page(usize),
    /// Search result from API.
    Result(Vec<SearchSeries>),
    /// Images have been loaded.
    ImagesLoaded(Vec<(Image, Handle)>),
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct Search {
    text: String,
    series: Vec<SearchSeries>,
    page: usize,
    /// Image IDs to load.
    pub(crate) image_ids: VecDeque<Image>,
}

impl Search {
    /// Handle theme change.
    pub(crate) fn update(&mut self, service: &mut Service, message: M) -> Command<Message> {
        match message {
            M::Search => {
                self.page = 0;

                let query = self.text.clone();
                let client = service.client.clone();

                let op = async move { client.search_by_name(&query).await };

                let out = |out| match out {
                    Ok(series) => Message::Search(M::Result(series)),
                    Err(error) => Message::error(error),
                };

                Command::perform(op, out)
            }
            M::Change(text) => {
                self.text = text;
                Command::none()
            }
            M::Page(page) => {
                self.page = page;
                Command::none()
            }
            M::Result(series) => {
                self.image_ids.clear();
                self.image_ids.extend(series.iter().map(|s| s.poster));
                self.series = series;
                Command::batch(self.handle_image_loading(service))
            }
            M::ImagesLoaded(loaded) => {
                service.insert_loaded_images(loaded);
                let command = self.handle_image_loading(service);
                Command::batch(command)
            }
        }
    }

    /// Generate the view for the settings page.
    pub(crate) fn view(&self, service: &Service) -> Column<'static, Message> {
        let submit = button("Search");

        let submit = if !self.text.is_empty() {
            submit.on_press(Message::Search(M::Search))
        } else {
            submit
        };

        let mut results = column![].spacing(GAP2).padding(GAP);

        for series in self.series.iter().skip(self.page * PER_PAGE).take(PER_PAGE) {
            let handle = match service.get_image(&series.poster) {
                Some(handle) => handle,
                None => service.missing_banner(),
            };

            let id = RemoteSeriesId::TheTvDb { id: series.id };

            let track = if let Some(s) = service.get_series_by_remote(id).filter(|s| s.tracked) {
                button(text("Untrack").size(ACTION_SIZE))
                    .style(theme::Button::Destructive)
                    .on_press(Message::Untrack(s.id))
            } else {
                button(text("Track").size(ACTION_SIZE))
                    .style(theme::Button::Positive)
                    .on_press(Message::TrackRemote(id))
            };

            let overview = series
                .overview
                .as_ref()
                .map(|o| o.as_str())
                .unwrap_or_default();

            results = results.push(
                column![
                    row![
                        image(handle).height(Length::Units(100)),
                        column![text(&series.name).size(24), text(overview),].spacing(SPACE)
                    ]
                    .spacing(GAP),
                    track,
                ]
                .spacing(GAP),
            );
        }

        let mut pages = row![];

        if self.series.len() > PER_PAGE {
            let mut prev = button("previous page");
            let mut next = button("next page");

            if let Some(page) = self.page.checked_sub(1) {
                prev = prev.on_press(Message::Search(M::Page(page)));
            }

            if (self.page + 1) * PER_PAGE < self.series.len() {
                next = next.on_press(Message::Search(M::Page(self.page + 1)));
            }

            pages = row![
                prev,
                text(format!(
                    "{}-{} result(s)",
                    self.page * PER_PAGE,
                    ((self.page + 1) * PER_PAGE).min(self.series.len())
                )),
                next
            ]
            .align_items(Alignment::Center)
            .spacing(GAP)
            .padding(GAP);
        }

        column![
            text("Search"),
            row![
                text_input("Query...", &self.text, |value| Message::Search(M::Change(
                    value
                ))),
                submit,
            ],
            results,
            pages,
        ]
        .spacing(GAP)
        .padding(GAP)
    }

    fn handle_image_loading(&mut self, service: &Service) -> Option<Command<Message>> {
        fn translate(value: Result<Vec<(Image, Handle)>>) -> Message {
            match value {
                Ok(value) => Message::Search(M::ImagesLoaded(value)),
                Err(e) => Message::error(e),
            }
        }

        let id = self.image_ids.pop_front()?;
        Some(Command::perform(service.load_image(id), translate))
    }
}

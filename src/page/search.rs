use iced::widget::{button, column, image, row, text, text_input, Column};
use iced::{theme, Alignment};
use iced::{Command, Length};

use crate::assets::Assets;
use crate::message::Message;
use crate::model::{RemoteSeriesId, SearchSeries};
use crate::params::{default_container, ACTION_SIZE, GAP, GAP2, SPACE};
use crate::service::Service;

const PER_PAGE: usize = 5;

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum M {
    /// Fire of a search with the current input.
    Search,
    /// On input change.
    Change(String),
    /// Go to a different page.
    Page(usize),
    /// Search result from API.
    Result(Vec<SearchSeries>),
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct State {
    text: String,
    series: Vec<SearchSeries>,
    page: usize,
}

impl State {
    /// Prepare data that is needed for the view.
    pub(crate) fn prepare(&mut self, _: &Service, assets: &mut Assets) {
        assets.mark(
            self.series
                .iter()
                .map(|s| s.poster)
                .skip(self.page * PER_PAGE)
                .take(PER_PAGE),
        );
    }

    /// Handle theme change.
    pub(crate) fn update(
        &mut self,
        service: &mut Service,
        assets: &mut Assets,
        message: M,
    ) -> Command<Message> {
        match message {
            M::Search => {
                self.page = 0;

                let query = self.text.clone();
                let client = service.client.clone();

                let op = async move { client.search_by_name(&query).await };

                let out = |out| match out {
                    Ok(series) => Message::Search(M::Result(series)),
                    Err(error) => Message::error(error),
                };

                Command::perform(op, out)
            }
            M::Change(text) => {
                self.text = text;
                Command::none()
            }
            M::Page(page) => {
                self.page = page;
                assets.clear();
                Command::none()
            }
            M::Result(series) => {
                self.series = series;
                assets.clear();
                Command::none()
            }
        }
    }

    /// Generate the view for the settings page.
    pub(crate) fn view(&self, service: &Service, assets: &Assets) -> Column<'static, Message> {
        let mut results = column![].spacing(GAP2).padding(GAP2);

        for series in self.series.iter().skip(self.page * PER_PAGE).take(PER_PAGE) {
            let handle = match assets.image(&series.poster) {
                Some(handle) => handle,
                None => assets.missing_poster(),
            };

            let id = RemoteSeriesId::TheTvDb { id: series.id };

            let track = if let Some(s) = service.get_series_by_remote(id) {
                button(text("Remove").size(ACTION_SIZE))
                    .style(theme::Button::Destructive)
                    .on_press(Message::RemoveSeries(s.id))
            } else {
                button(text("Add").size(ACTION_SIZE))
                    .style(theme::Button::Positive)
                    .on_press(Message::AddSeriesByRemote(id))
            };

            let overview = series
                .overview
                .as_ref()
                .map(|o| o.as_str())
                .unwrap_or_default();

            results = results.push(
                column![row![
                    image(handle).height(Length::Units(200)),
                    column![
                        column![text(&series.name).size(24), track].spacing(SPACE),
                        text(overview),
                    ]
                    .spacing(GAP)
                ]
                .spacing(GAP),]
                .spacing(GAP),
            );
        }

        let mut pages = row![];

        if self.series.len() > PER_PAGE {
            let mut prev = button("previous page");
            let mut next = button("next page");

            if let Some(page) = self.page.checked_sub(1) {
                prev = prev.on_press(Message::Search(M::Page(page)));
            }

            if (self.page + 1) * PER_PAGE < self.series.len() {
                next = next.on_press(Message::Search(M::Page(self.page + 1)));
            }

            pages = row![
                prev,
                text(format!(
                    "{}-{} result(s)",
                    self.page * PER_PAGE,
                    ((self.page + 1) * PER_PAGE).min(self.series.len())
                )),
                next
            ]
            .align_items(Alignment::Center)
            .spacing(SPACE)
            .padding(SPACE);
        }

        let query = text_input("Query...", &self.text, |value| {
            Message::Search(M::Change(value))
        })
        .on_submit(Message::Search(M::Search));

        let submit = button("Search");

        let submit = if !self.text.is_empty() {
            submit.on_press(Message::Search(M::Search))
        } else {
            submit
        };

        let page = column![text("Search"), row![query, submit,], results, pages]
            .spacing(GAP)
            .padding(GAP);

        default_container(page)
    }
}

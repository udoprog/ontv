use iced::theme;
use iced::widget::{button, column, container, image, row, text};
use iced::{Alignment, Command, Element, Length};

use crate::message::Message;
use crate::params::{ACTION_BUTTON_SIZE, GAP, SPACE};
use crate::service::Service;

/// Message generated by dashboard page.
#[derive(Debug, Clone)]
pub(crate) enum M {
    Watched,
}

/// The state for the settings page.
#[derive(Default)]
pub(crate) struct Dashboard {}

impl Dashboard {
    /// Handle theme change.
    pub(crate) fn update(&mut self, message: M) -> Command<Message> {
        match message {
            M::Watched => {
                log::info!("watched");
            }
        }

        Command::none()
    }

    /// Generate the view for the settings page.
    pub(crate) fn view(&self, service: &Service) -> Element<'static, Message> {
        let mut series = row![].spacing(GAP);

        for s in service.list_series().take(5) {
            let mut buttons = row![]
                .width(Length::Fill)
                .spacing(SPACE)
                .align_items(Alignment::Start);

            if true {
                buttons = buttons.push(
                    button(text("mark watched").size(ACTION_BUTTON_SIZE))
                        .style(theme::Button::Primary)
                        .on_press(Message::Dashboard(M::Watched)),
                );
            }

            let handle = match service.get_image(&s.poster) {
                Some(handle) => handle,
                None => service.missing_poster(),
            };

            series = series.push(
                column![
                    container(image(handle)).max_height(500),
                    buttons,
                    text(&s.title),
                ]
                .align_items(Alignment::Center)
                .spacing(GAP)
                .width(Length::FillPortion(1)),
            );
        }

        series.width(Length::Fill).padding(GAP).spacing(GAP).into()
    }
}
